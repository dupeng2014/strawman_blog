title = '智能金融起锚:文因、数库、通联瞄准的kensho革命'
text = '''2015年9月13日,39岁的鲍捷乘上从硅谷至北京的飞机,开启了他心中的金融梦想。

鲍捷,人工智能博士后,如今他是文因互联公司创始人兼CEO。和鲍捷一样,越来越多的硅谷以及华尔街的金融和科技人才已经踏上了归国创业征程。

在硅谷和华尔街,已涌现出Alphasense、Kensho等智能金融公司。

如今,这些公司已经成长为独角兽。

大数据、算法驱动的人工智能已经进入到金融领域。人工智能有望在金融领域最新爆发。

前段时间,笔者写完了《激荡二十五年:Wind、同花顺、东方财富、大智慧等金融服务商争霸史》、《边缘崛起:雪球、老虎、富途、牛股王等互联网券商的新玩法》,探讨了互联网时代、移动互联网时代创业者们的创想。

人工智能与金融正在融合,这里我们聚焦一下投研领域,后续会向交易、投顾等领域延展。这篇文章将描绘一下Kensho、文因互联、数库科技、通联数据在这个领域的探索和尝试,看看新时代正在掀起的巨浪。

1、Kensho的颠覆式革命

华尔街的Kensho是金融数据分析领域里谁也绕不过的一个独角兽。这家公司获得由高盛领投的6280万美元投资,总融资高达7280万美元。

33岁的Kensho创始人Daniel Nadler预言:在未来十年内,由于Kensho和其他自动化软件,金融行业有三分之一到二分之一的雇员将失业。

2014年,Nadler在哈佛大学学习数学和古希腊文化。大学期间,他在美联储担任访问学者时惊奇地发现,这家全球最具权势的金融监管机构仍然依靠Excel来对经济进行分析。

当时,希腊选举以及整个欧洲的不稳定局面正强烈冲击金融市场。访问期间,Nadler意识到无论是监管者还是银行家,除了翻过去的新闻消息以外,并不能给出什么好的方案。

于是,他和麻省理工学院的好友一起想办法,并借鉴Google的信息处理方法,来分析资本市场,设计出了Kensho软件。

一个典型的工作场景是:早上八点,华尔街的金融分析师冲进办公室,等待即将在8点半公布的劳工统计局月度就业报告。他打开电脑,用Kensho软件搜集劳工部数据。

两分钟之内,一份Kensho自动分析报告便出现在他的电脑屏幕上:一份简明的概览,随后是13份基于以往类似就业报告对投资情况的预测。

金融分析师们再无需检查,因为Kensho提取的这些分析基于来自数十个数据库的成千上万条数据。

Kensho界面与Google相似,由一条简单的黑色搜索框构成。其搜索引擎自动将发生的事件根据抽象特征进行分类。

福布斯报道过运用Kensho的成功案例。例如,英国脱欧期间,交易员成功运用Kensho了解到退欧选举造成当地货币贬值;此外,Kensho还分析了美国总统任期的前100天内股票涨跌情况(见下图):

(图片来源:福布斯)

Kensho在构建金融与万物的关联,并用结构化、数据化的方式去呈现。公司还专门雇佣了一位机器学习专家,而这位专家此前为谷歌研究世界图书馆的大型分类方法。

处理复杂的事件与投资关联,Kensho只需要几分钟。但是在华尔街一个普通的分析师需要几天时间去测算对各类资产的影响。而这些分析师普遍拿着30—40万美元的年薪。

此外,硅谷的创业公司AlphaSense公司已经悄然建成了一个解决专业信息获取和解决信息碎片问题的金融搜索引擎。

AlphaSense的首席执行官Jack Kukko曾是摩根士丹利分析师,这赋予了其强大的金融基因。

AlphaSense可以搜索“研究文献,包括公司提交的文件证明、演示、实时新闻、新闻报道、华尔街的投资研究、以及客户的内部内容。”

AlphaSense几秒钟内即可搜索数百万个不同的财务文档, 公司内部纰漏内容和卖方研究等,使用户可以快速发现关键数据点,并通过智能提醒、跟踪重要信息点、防止数据遗漏,做出关键的决策。

AlphaSense目前已经向包括摩根大通等投资和咨询公司、全球银行、律师事务所和公司(如甲骨文)等500余位客户提供服务。

2、海归博士的智能金融实验

2017年6月,在北京朝阳区的一个居民楼的办公室内,鲍捷和他的20名创业伙伴正在摸索打造一款智能金融分析工具,而他的目标正是华尔街的AlphaSense和Kensho。

41岁的鲍捷很享受创业,他说在中国这是最好的创业时代。在此之前,他有一段漫长的求学历程。

鲍捷是一个信息整理控,他从小学开始整理所有的历史人物、水文地理、卡通人物的关系等。合肥工业大学研究生阶段,他师从德国斯图加特大学归来的博士高隽,学习人工智能,深度研究神经网络。

2001年,他离开中国进入美国,先后为Lowa State Univ博士、RPI博士后、MIT访问研究员、BBN访问研究员,在美国完成了11年人工智能的学习和研究。他先后师从语义网创始人Jim Hendler和万维网发明人、图灵奖得主Tim Berners-Lee,参与了语义网学科形成期间的一些关键研究项目,并是知识图谱国际标准OWL的作者之一。

2013年,在三星研究院工作不到两年后,他开始了在硅谷的创业,研发了一款名为“好东西传送门”的产品。

该产品主要利用机器人程序在网站抓取人工智能、机器学习、大数据的最新技术资讯,利用专业领域知识过滤后,自动生产内容,传送至需要的人。

好东西传送门获取了数万铁粉,但无法盈利。2015年9月,他离开硅谷飞往北京,归国的第一天,便获得了无量资本100万美元的天使轮融资。他在中国创立了“文因互联”。

其实鲍捷很早就看到了人工智能和金融结合的前景。在2010年,他就提出了金融报表语言XBRL的语义模型。2015年底,他看到了Kensho在金融领域带来的革命,结合国内的投资需求,他选择了在新三板领域开始切入,当时只有7名员工,经过半年研发,文因在2016年5月推出了“快报”和“搜索”。

“快报”能够自动抓取每日公告、财报、新闻资讯等;而“搜索”能够自动提取产业链上下游公司、结构化财报等各类数据。

“这两款产品为我们获取了1万铁粉,虽然产品有很多缺陷,但是依旧很多人喜欢这个工具,因为以前没有能够满足这种需求的服务。”鲍捷向华尔街见闻表示。

但是他们发现做搜索需要庞大的知识架构,需要去集成各种金融相关数据,开发公司标签、产业标签、产业链等复杂的知识图谱,而做这个体系,再烧几亿,可能也无法完成。

更为恐怖的是,做完产品还要和金融信息服务商竞争。Wind、同花顺、东方财富,挡在了文因互联面前。

“我放弃了从头到尾设计一个大系统的想法,而是从具体场景出发解决单点问题。从年底开始我分了一部分人去做项目,但每一个项目都是我们大系统里面的一个组件,这个项目根据金融客户的真实需求去打磨,然后将这些组件整合为一个系统的产品。”鲍捷反思道,创业需要寻找用户最痛的点,然后扎下去解决问题。

经过一年的创业,鲍捷变得更接地气。去年下半年以来,他密集地拜访各大银行、基金、保险、券商,根据金融机构的需求,在标准化产品之上定制化,从具体业务的自动化出发走向智能化。

目前恒丰银行、南京银行、中债资信等均已成为文因互联的合作客户。

文因互联很快根据金融机构的需求开发出了公告摘要、自动化报告、财报结构化数据等多个软件产品,并开发出了投研小机器人。

2016年年底,文因互联再次获得睿鲸资本Pre-A轮融资。而这位睿鲸资本的投资人,曾经是鲍捷的网友,他们经常在一起讨论人工智能问题。

鲍捷举例说,深市、沪市、新三板加在一起每天平均大概3000-4000份公告,每天处理公告数据提取和摘要,这是一件非常繁琐的事情。很多金融机构要养20多人处理公告,而且这些人还不能快速高效准确地处理。这类事情机器做最适合。给机器程序输入金融知识,并通过模型训练,能够快速准确地提取各项公告摘要和年报摘要。

鲍捷表示,文因互联长远目标是Kensho,用人工智能提升金融投研效率和渠道效率,而这还有很长的路要走。

3、中国式创新距离Kensho有多远?

上海的另外一位海归,也选择在金融研投领域创业,他叫刘彦,已经归国创业了八年。

八年前,他创立的数库科技,如今获得了京东金融1000万美元的投资。

2003年,23岁的他从密歇根商学院毕业,进入华尔街瑞信公司,一年后他主动调到香港分公司。 5年里,他主导完成了建设银行、工商银行、太平洋保险等大公司的上市项目。

华尔街2008年的金融危机波及全球,人性的贪婪和恐惧暴露无遗。在刘彦眼里,从数据层面到决策层面,每一个环节都充斥着被加工过的信息。2009年,他选择回到上海创业。刘彦最初的野心很大,想构建中国的彭博终端,他花费两年的时间构建完成“半结构化数据”。

2011年,数库获得穆迪资本500万美元投资。很快,原公司从70人扩张到140人。但因数库的战略计划并未完成,穆迪资本放弃进一步投资,他和联合创始人沈鑫卖掉房子,继续维持运营。

刘彦破釜沉舟,公司很快攻克了信息识别系统和精度抓取,并在深度分析等方面取得突破。

数库科技试图覆盖全球上市公司:A股3218家、港股1993家美股4953家、新三板10725家、非上市金融490家、股权交易中心2467家。

目前,数库主要服务于B端金融机构。数库自称核心独家的产品有两款:其一、SAM(Segment Analytics Mapping)行业分析工具。数库是根据上市公司实际披露的产品分项推导出其行业分类,会根据上市公司的定期报告实时做出调整。数库行业分类,分为10个层级,4000个产品节点,帮助投资者快速了解产业竞争环境、系统化对比公司财务及运营数据。其二、产业链的分析工具。数库在行业分析工具SAM的基础上,衍生出的一个分析工具。从产业链条的角度,将上市公司通过产品相互关联,帮助投资人优先布局上下游的投资机会。

刘彦的终极理想是通过科技的发展,使金融从“投机”和“博弈”中逐渐走出来,走向非人为的自动化运行,把专业人士和投资弱势群体之间的距离拉近,使个人拥有机构投资者的能力。

这两年,科技金融成为创投最热的风口。中国的大集团也瞄准了这个产业变革的机会。国内民营巨头万向集团看准了智能金融这个方向。

2011年,万向集团挖来了时任博时基金总经理肖风,担任万向集团副董事长。他迅速构建起庞大的金融帝国:浙商银行、浙商基金、民生人寿、万向财务、通联数据等公司。

2013年12月,注册资本3亿元的通联数据在上海创立,肖峰为创始人兼董事长。

通联数据的野心很庞大,目前员工达到300人,正面与Wind、同花顺、东方财富竞争,并推出了PC和移动端的资产管理业务的一站式服务平台,内容涵盖大数据分析、智能投资研究、量化研究、智能投顾和资产配置管理服务等多个领域。

通联数据认为,自己的核心是有一批高素质的技术人才,同时还有顶级金融人才。

2017年6月6日,恒生电子正式面向金融机构推出最新的人工智能产品:涵盖智能投资、智能资讯、智能投顾、智能客服四大领域。其中一款产品智能小梵可通过强大人机自然交互,提供精准数据提炼及智能资讯分析。

在笔者的走访中,越来越多高科技人才、金融人才进入智能金融投研领域,这个领域已经成为红海。

谁能够乘着人工智能浪潮,成为新一代的金融信息服务终端?

敬请关注后续报道。
'''
# -*- coding: utf-8 -*-
import jieba, copy, re, codecs
from collections import Counter
import nltk

# from text import title, text


class Summary():
    # **** 切分句子 ************
    def cutSentence(self, text):
        sents = []
        text = re.sub(r'\n+', '。', text)  # 换行改成句号（标题段无句号的情况）
        text = text.replace('。。', '。')  # 删除多余的句号
        text = text.replace('？。', '。')  #
        text = text.replace('！。', '。')  # 删除多余的句号
        sentences = re.split(r'。|！|？|】|；', text)  # 分句
        # print(sentences)
        sentences = sentences[:-1]  # 删除最后一个句号后面的空句
        for sent in sentences:
            len_sent = len(sent)
            if len_sent < 4:  # 删除换行符、一个字符等
                continue
            # sent = sent.decode('utf8')
            sent = sent.strip('　 ')
            sent = sent.lstrip('【')
            sents.append(sent)
        return sents

    # **** 提取特征词 **********************
    def getKeywords(self, title, sentences, n=10):
        words = []
        # **** 分词，获取词汇列表 *****
        # split_result = pseg.cut(text)
        for sentence in sentences:
            split_result = jieba.cut(sentence)
            for i in split_result:
                words.append(i)
        # **** 统计词频TF *****
        c = Counter(words)  # 词典
        # **** 去除停用词(为了提高效率，该步骤放到统计词频之后)
        self.delStopwords(c)
        # **** 标题中提取特征 *********
        words_title = [word for word in jieba.cut(title, cut_all=True)]
        self.delStopwords(words_title)
        # **** 获取topN ************
        topN = c.most_common(n)
        # for i in topN:
        #     print(i[0],i[1])
        words_topN = [i[0] for i in topN if i[1] > 1]  # 在topN中排除出现次数少于2次的词

        words_topN = list(set(words_topN) | set(words_title))  # 正文关键词与标题关键词取并集

        print(' '.join(words_topN))
        return words_topN

    # **** 去除停用词 *******************************
    def delStopwords(self, dict):
        sw_file = codecs.open('stopword.txt', encoding='utf8')

        stop_words = []
        for line in sw_file.readlines():
            stop_words.append(line.strip())
        # ***** 输入参数为list *************
        # if type(dict) is types.ListType:
        if type(dict) is list:
            words = dict
            for word in words:
                if word in stop_words:
                    words.remove(word)
        # ***** 输入参数type为 <class 'collections.Counter'>  *****
        else:
            words = copy.deepcopy(list(dict.keys()))
            for word in words:
                if word in stop_words:
                    del dict[word]
        return words

    # **** 提取topN句子 **********************
    def getTopNSentences(self, sentences, keywords, n=3):
        sents_score = {}
        len_sentences = len(sentences)
        # **** 初始化句子重要性得分，并计算句子平均长度
        len_avg = 0
        len_min = len(sentences[0])
        len_max = len(sentences[0])
        for sent in sentences:
            sents_score[sent] = 0
            l = len(sent)
            len_avg += l
            if len_min > l:
                len_min = l
            if len_max < l:
                len_max = l
        len_avg = len_avg / len_sentences
        # print(len_min,len_avg,len_max)
        # **** 计算句子权重得分 **********
        for sent in sentences:
            # **** 不考虑句长在指定范围外的句子 ******
            l = len(sent)
            if l < (len_min + len_avg) / 2 or l > (3 * len_max - 2 * len_avg) / 4:
                continue
            words = []
            sent_words = jieba.cut(sent)  # <generator object cut at 0x11B38120>
            for i in sent_words:
                words.append(i)
            keywords_cnt = 0
            len_sent = len(words)
            if len_sent == 0:
                continue

            for word in words:
                if word in keywords:
                    keywords_cnt += 1
            score = keywords_cnt * keywords_cnt * 1.0 / len_sent
            sents_score[sent] = score
            if sentences.index(sent) == 0:  # 提高首句权重
                sents_score[sent] = 2 * score
        # **** 排序 **********************
        dict_list = sorted(sents_score.items(), key=lambda x: x[1], reverse=True)
        # print(dict_list)
        # **** 返回topN ******************
        sents_topN = []
        for i in dict_list[:n]:
            sents_topN.append(i[0])
            # print i[0],i[1]
        sents_topN = list(set(sents_topN))
        # **** 按比例提取 **************************
        if len_sentences <= 5:
            sents_topN = sents_topN[:1]
        elif len_sentences < 9:
            sents_topN = sents_topN[:2]

        return sents_topN

    # **** 恢复topN句子在文中的相对顺序 *********
    def sents_sort(self, sents_topN, sentences):
        keysents = []
        for sent in sentences:
            if sent in sents_topN and sent not in keysents:
                keysents.append(sent)
        keysents = self.post_processing(keysents)

        return keysents

    def post_processing(self, keysents):
        # **** 删除不完整句子中的详细部分 ********************
        detail_tags = ['，一是', '：一是', '，第一，', '：第一，', '，首先，', '；首先，']
        for i in keysents:
            for tag in detail_tags:
                index = i.find(tag)
                if index != -1:
                    keysents[keysents.index(i)] = i[:index]
        # **** 删除编号 ****************************
        for i in keysents:
            # print(i)
            regex = re.compile(r'^一、|^二、|^三、|^三、|^四、|^五、|^六、|^七、|^八、|^九、|^十、|^\d{1,2}、|^\d{1,2} ')
            result = re.findall(regex, i)
            if result:
                keysents[keysents.index(i)] = re.sub(regex, '', i)
        # **** 删除备注性质的句子 ********************
        for i in keysents:
            regex = re.compile(r'^注\d*：')
            result = re.findall(regex, i)
            if result:
                keysents.remove(i)
        # **** 删除句首括号中的内容 ********************
        for i in keysents:
            regex = re.compile(r'^\[.*\]')
            result = re.findall(regex, i)
            if result:
                keysents[keysents.index(i)] = re.sub(regex, '', i)
        # **** 删除来源(空格前的部分) ********************
        for i in keysents:
            regex = re.compile(r'^.{1,20} ')
            result = re.findall(regex, i)
            if result:
                keysents[keysents.index(i)] = re.sub(regex, '', i)
        # **** 删除引号部分（如：银行间债市小幅下跌，见下图：） ********************
        for i in keysents:
            regex = re.compile(r'，[^，]+：$')
            result = re.findall(regex, i)
            if result:
                keysents[keysents.index(i)] = re.sub(regex, '', i)

        return keysents

    def main(self, title, text):
        sentences = self.cutSentence(text)
        keywords = self.getKeywords(title, sentences, n=8)
        sents_topN = self.getTopNSentences(sentences, keywords, n=3)
        keysents = self.sents_sort(sents_topN, sentences)
        print(keysents)
        return keysents


if __name__ == '__main__':
    summary = Summary()
    summary.main(title, text)


